// CUP specification for a simple expression evaluator (w/ actions)

import java_cup.runtime.*;
import java.util.Vector;
import java.io.*;

parser code {:
       public boolean do_debug_parse = false;

       public void debug_message(String mess)
       {
       	      System.err.println(mess);
       }

       public void syntax_error(Symbol cur_token)
       {
       report_error("Syntax error at character "+(cur_token.right +1)+" on line "+ (cur_token.left+1), null);
       }

       public void unrecovered_syntax_error(Symbol cur_token)
       	      throws java.lang.Exception{
	      report_fatal_error("Couldn't repair and continue parse at character "
                  + (cur_token.right + 1)+ " on line " + (cur_token.left+1), null);
	      }
:};

/*
-----------------------------------------------------------------------
-                                types                                -
-----------------------------------------------------------------------
*/
terminal PROC,STRUCT, MAIN, INT, CHAR, FLOAT,STR , BOOL, LIST, POINTER, CLASS,TP;
/*
-----------------------------------------------------------------------
-                             opareators                              -
-----------------------------------------------------------------------
*/
terminal MULT, MOD, MIN, DIV, NOT, AND, TRUE, FALSE, NULL,INF, PLUS, SUP, OR;
terminal EQ, EQUALS, GEQL, LEQL, DIFF, COLON;
/*
-----------------------------------------------------------------------
-                             separators                              -
-----------------------------------------------------------------------
*/
terminal LPAR,RPAR,SEMIC,NEWBLOCK,ENDBLOCK, COMMA; 
terminal IF, ELSE, WHILE, EXIT, RETURN;
/*
-----------------------------------------------------------------------
-                              specials                               -
-----------------------------------------------------------------------
*/
terminal String STRING; 
terminal String ID;
terminal Integer NB;



/* The grammar */
non terminal expr, term, factor;
non terminal axiom, axioms, keyword, type, complextype, program;
non terminal declaration, function, codeblock,value, parameters, instruction, main;
precedence left OR,AND;
precedence left PLUS, MIN;
precedence left MULT, DIV, MOD;
precedence nonassoc EQUALS, DIFF, LEQL , GEQL , INF , SUP ,NOT; 


start with program;

//declares a program as a suit of declarations
program::=instruction             {: System.out.println("inst"); :}
    |instruction main instruction {: System.out.println("inst main main");:}
    ;

instruction::= declaration instruction
    |
    ;
//a declaration cam be a var declaration or a function
declaration::= ID:id COLON type:t SEMIC {: System.out.println("dec -> dec not init");:}
    |ID:id COLON type:t  EQ value SEMIC {: System.out.println("dec -> dec init");:}
    |ID:id COLON complextype SEMIC      {: System.out.println("dec -> complex dec not init");:}
    |TP:t1 ID:t2 EQ complextype SEMIC   {: System.out.println("dec -> complex dec init");:}
    |TP:t1 ID:t2 EQ type SEMIC          {: System.out.println("dec -> complex dec init");:}
    |function
    ;

main::= MAIN LPAR parameters RPAR codeblock {: System.out.println("main declaration");:}
    ;


//the basis os a function declaration
function::= type:t ID:id LPAR parameters RPAR codeblock 
            {: System.out.println("function");:}
    ;

//the codeblock structure
codeblock::= NEWBLOCK instruction ENDBLOCK {: System.out.println("codeblock"); :};

//function parameters
parameters::= ID:id type:t                 {: System.out.println("parameter");:}
    |ID:id type:t COMMA parameters         {: System.out.println("mult parameters");:}
    |
    ;

//a basic recuperation of the value and type
value ::= ID:t {: System.out.println(t);:}
    | STRING:t {: System.out.println(t);:}
    | NB:t     {: System.out.println(t);:}
    ;

/*program structure
program::= instruction
	   {: System.out.println("instruction") :}
	   |program instruction
	   {: System.out.println("instruction") :}
	   ;

//instruction structure
instruction::=
*/

/*
-----------------------------------------------------------------------
- i left your code here commented but have a look on what i did that
- is just the start as we can recoginize a function and simple declaration s
----------------------------------------------------------------------
*/

/*
axioms ::=	axiom:t1 axioms:t2 {}
    | axiom:t {}
    ;

axiom ::= expr:t SEMIC           {: System.out.println("axiom -> expr SEMIC"); :}
	| keyword:t SEMIC            {: System.out.println("axiom -> keyword SEMIC"); :}
	| type:t SEMIC               {: System.out.println("axiom -> type SEMIC"); :}
	| complextype:t SEMIC        {: System.out.println("axiom -> complextype SEMIC"); :}
    ;

expr ::= expr:t1 PLUS term:t2    {: System.out.println("expr -> expr + term"); :}
    | term:t                     {: System.out.println("expr -> term"); :}
    ;

term ::= term:t1 MULT  factor:t2 {: System.out.println("terme -> terme MULT facteur"); :}
    | factor:t                   {: System.out.println("terme -> facteur"); :}
    ;

factor ::= LPAR expr:t  RPAR     {: System.out.println("factor -> LPAR expr RPAR"); :}
    | ID:t                       {: System.out.println("factor -> ID"); :}
    ;

keyword ::=	PROC:t               {: System.out.println("keyword -> procedure"); :}
		| MAIN:t                 {: System.out.println("keyword -> main"); :}
		;
        */
/*
-----------------------------------------------------------------------
-                           possible types                            -
-----------------------------------------------------------------------
*/
type ::= INT:t {: System.out.println("type -> integer"); :}
    | CHAR:t   {: System.out.println("type -> character"); :}
    | FLOAT:t  {: System.out.println("type -> float"); :}
    | BOOL:t   {: System.out.println("type -> boolean"); :}
    | STR:t    {: System.out.println("type -> string"); :}
    | PROC:t   {: System.out.println("type -> procedure"); :}
    ;

complextype ::= CLASS:t1 codeblock {: System.out.println("complextype -> class"); :}
    | LIST:t1 type:t2              {: System.out.println("complextype -> list of"); :}
    | POINTER:t1 type:t2           {: System.out.println("complextype -> ^"); :}
    | STRUCT:t1 codeblock :t2      {: System.out.println("complextype -> structure"); :}
    ;
